<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Plot</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #angle {
            position: absolute;
            color: white;
        }
    </style>
</head>

<body>
    <div id="angle"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Создание сцены
        const scene = new THREE.Scene();

        // Камера
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 300;

        // Рендерер
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Оси (AxesHelper)
        const axesHelper = new THREE.AxesHelper(5);  // Размер осей
        scene.add(axesHelper);

        // Функции для рисования графиков
        function plotLine(func, color) {
            const material = new THREE.LineBasicMaterial({ color: color });
            const points = [];

            for (let x = 0; x <= 100; x += 1) {
                const y = func(x);
                points.push(new THREE.Vector3(x, y, 0));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        const k1 = 0.5;
        const k2 = 3;

        // Вычисление угла между прямыми
        const angleInRadians = Math.atan(Math.abs((k1 - k2) / (1 + k1 * k2)));

        // Преобразуем радианы в градусы, если нужно
        const angleInDegrees = angleInRadians * (180 / Math.PI);

        document.getElementById("angle").textContent = angleInDegrees;

        // Определяем функции
        function func1(x) {
            return k1 * x;
        }

        function func2(x) {
            return k2 * x + 1;
        }

        function func(x) {
            return x % 2 === 0 ? func1(x) : func2(x);
        }

        // Рисуем функции
        plotLine(func1, 0xff0000);  // Красный для y = x / 2
        plotLine(func2, 0x0000ff);  // Синий для y = 3 * x + 1

        function addPointToScene(scene, x, y, z, color = 0xff0000, size = 1) {
            // Создаем геометрию для точки
            const geometry = new THREE.SphereGeometry(size, 8, 8);

            // Создаем материал для точки
            const material = new THREE.MeshBasicMaterial({ color: color });

            // Создаем меш (объект) из геометрии и материала
            const point = new THREE.Mesh(geometry, material);

            // Устанавливаем позицию точки в пространстве
            point.position.set(x, y, z);

            // Добавляем точку в сцену
            scene.add(point);
        }

        addPointToScene(scene, 15, 46, 0);
        addPointToScene(scene, 46, 23, 0);
        addPointToScene(scene, 23, 70, 0);
        addPointToScene(scene, 70, 35, 0);
        addPointToScene(scene, 35, 106, 0);
        addPointToScene(scene, 106, 53, 0);
        addPointToScene(scene, 53, 160, 0);
        addPointToScene(scene, 160, 80, 0);

        function getRandomColor() {
            // Генерируем случайное число от 0 до 16777215 (0xFFFFFF)
            const randomColor = Math.floor(Math.random() * 16777215);

            // Возвращаем его в формате 0xRRGGBB
            return randomColor;
        }

        // Функция для анимации рисования линии из одной точки в другую
        async function drawLineAnimation(startPoint, endPoint) {
            return new Promise((resolve) => {
                // Создаем материал для линии
                const lineMaterial = new THREE.LineBasicMaterial({ color: getRandomColor() });

                // Создаем массив для точек линии, начинаем с начальной точки
                const points = [startPoint.clone()]; // Начальная точка

                // Создаем геометрию и линию
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);

                // Переменные для анимации
                let currentStep = 0;
                const steps = 100;  // Число шагов для анимации (чем больше, тем плавнее)

                // Функция анимации
                function animateLine() {
                    if (currentStep <= steps) {
                        // Вычисляем текущую промежуточную точку
                        const t = currentStep / steps;
                        const x = startPoint.x + (endPoint.x - startPoint.x) * t;
                        const y = startPoint.y + (endPoint.y - startPoint.y) * t;
                        const z = startPoint.z + (endPoint.z - startPoint.z) * t;

                        // Добавляем точку на линию
                        points.push(new THREE.Vector3(x, y, z));

                        // Обновляем геометрию линии
                        geometry.setFromPoints(points);

                        currentStep++; // Увеличиваем шаг
                    } else {
                        // Когда анимация завершена, разрешаем промис с последней точкой
                        resolve(points[points.length - 1]); // Возвращаем последнюю точку
                    }

                    renderer.render(scene, camera);
                    requestAnimationFrame(animateLine);
                }

                animateLine(); // Запуск анимации
            });
        }

        async function main() {
            const number = 15;

            let startPoint = new THREE.Vector3(number, 0, 0);
            let endPoint = new THREE.Vector3(number, func(number), 0);

            while (startPoint.x !== 1) {
                const lastPoint = await drawLineAnimation(startPoint, endPoint);
                startPoint = new THREE.Vector3(lastPoint.x, lastPoint.y, 0);
                endPoint = new THREE.Vector3(lastPoint.y, func(lastPoint.y), 0);
            }

            alert('закончил')
        }

        main();
    </script>
</body>

</html>
